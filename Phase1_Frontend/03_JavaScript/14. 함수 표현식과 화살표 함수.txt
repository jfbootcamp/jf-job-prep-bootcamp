1. intro
    1) JavaScript 코드의 80%는 함수로 이루어져 있음 
    2) 화살표 함수를 기본으로 사용 
    3) 코드 가독성 

2. 함수 선언문 
    1) function 키워드로 시작
    2) 함수 이름 필수 
    3) 호이스팅 O 
        - 선언 전에도 호출 가능 
    4) 예
        function addDeclaration(a, b) {     // a, b는 매개변수(parameter) : 받을 값의 이름
            return a + b;                   // return : 함수 실행 결과를 반환
        }            

        addDeclaration(10, 20);             // 10, 20는 인수(argument) : 실제 전달 값

3. 함수 표현식 (Function Expression)
    1) 함수를 변수에 할당하는 방식         
    2) 함수도 "값"처럼 취급 됨
    3) const: 상수 선언 (재할당 불가)
    4) 예
        const addExpression = function(a, b) {
            return a + b;
        };
    5) 익명 함수 (이름 없음)
    6) 호이스팅 X : 선언 후에만 호출 가능 
    7) 변수 할당문으로 세미콜론 필수 

4. 화살표 함수 
    1) ES6 에서 도입된 간결한 함수 표현 방식
    2) function 키워드 대신 =>(화살표) 사용 
    3) 중괄호 {}를 사용하면 return 명시 필요함    
    4) 예 
       const addArrow = (a, b) => a + b;    // 한줄로 끝! { } return 없음!
    5) 축약형 (가장 많이 사용)
        - 본문이 한 줄(표현식 하나)일 때 더 짧게 작성   
        - (a, b) => { return a + b; } 와 동일 
        - { } 생략 + return 생략 (암시적 반환)
            - (a, b) => a + b;

    6) 매개변수 개수에 따른 괄호 규칙 
        - 매개변수 1개 --> () 생략 가능
            - 예
                const doubleVar = x => x * 2;
                                ------------
                                x를 받아서 x*2를 반환한다

                                (x) => x * 2;와 동일함

        = 매개변수 0개 -->  () 필수!
            - 예 
                const sayHello = () => "안녕!";
            
            - 빈 괄호는 반드시 필요 (생략 불가)
            - 고정 값 반환     

5. 배열 메서드 
    1) 화살표 함수는 배열 메서드와 함께 가장 많이 사용됨 

    2) map()
        - 변환(mapping)하다
        - 배열의 각 요소를 변환하여 새 배열 반환 
        - 원본 배열은 그대로!     
        - 예
                const numbers = [1, 2, 3, 4, 5];            // 숫자 5개가 담긴 배열 

                const doubleVar = numbers.map(n => n * 2);  // 각 요소 n을 받아서 n * 2로 변환

                - 동작 흐름
                    - [1, 2, 3, 4, 5] ---> [1* 2, 2* 2, 3* 2, 4* 2, 5* 2]
                      ---> [2, 4, 6, 8, 10]



        - 새로운 형태의 객체로 변환 
            - 화살표 함수에서 { }는 두 가지 의미가 있음
                - ① 함수 본문(body)을 나타내는 중괄호 : () => { 코드... }
                - ② 객체 리터럴을 나타내는 중괄호 : { key: value }

            - JavaScript 엔진은 { }를 보면 "함수 본문"으로 먼저 해석함!
                - 해결책 1: 소괄호 ( )로 감싸기 => "이건 표현식이야" 라고 알려주는 것 
                                             => JS 엔진 { }를 객체 리터럴로 해석함 
                - 명시적 return 사용 => return 뒤의  { }는 객체 리터럴로 해석함  




    3) filter()         
        - 걸러내다 
        - 조건을 만족하는 요소만 걸러서 새 배열 반환             
        - 원본 배열은 그대로!     
        - 콜백이 true 반환하면 포함, false면 제외
        - 예
                const numbers = [1, 2, 3, 4, 5];            // 숫자 5개가 담긴 배열

                const evens = numbers.filter(n => n % 2 === 0);  // n을 2로 나눈 나머지가 0인지 확인 (짝수 판별)

                - 동작 흐름
                    - [1, 2, 3, 4, 5] ---> 2와 4만 조건 만족 ---> [2, 4]

    4) reduce()
        - 줄이다, 축소하다 
        - 배열의 모든 요소를 하나의 값으로 축소  
        - 예
            const numbers = [1, 2, 3, 4, 5];            // 숫자 5개가 담긴 배열    

            const sum = numbers.reduce((acc, n) => acc + n, 0)      // 0: 초기값 (acc의 시작값) , n: 현재 요소

            - 동작 흐름 
                - 0 ---> 0+1=1 ---> 1+2=3 ---> 3+3=6 ---> 6+4=10 ---> 10+5=15 
                - 최종 결과: 15

6. 콜백 함수와 고차 함수 (Higher-Order Function) 
    1) 고차 함수 
        - 함수를 매개변수로 받는 함수 
        - 예
            const addAndCallback = (a, b, callback) => {
                let result = a + b;     // 1단계: 계산
                callback(result);       // 2단계: 콜백 실행
            }

            - callback : 세번째 매개변수로 "함수"를 받음     
            - 계산(a+b)은 여기서 하고, 결과 처리는 전달 받은 함수(callback)에 위임
            - 실행 흐름
                - ① a=5, b=3, callback=showResult로 호출 (callback=showDouble로 호출)
                - ② result = 5 + 3 = 8
                - ③ showResult(8) 실행 ---> "8" 출력      (showDouble(8) 실행)

    2) 콜백 함수 정의 - 결과를 처리하는 함수 
        - 예 (결과를 단순히 출력하는 함수)

            const showResult = (result) => {        // 매개변수 result: addAndCallback에서 전달 받은 값
                console.log('결과 : ' + result);
            }                            

        - 예 (결과를 2배로 만드는 함수)            

            const showDouble = (result) => {
                console.log('2배 : ' + result * 2);
            }

        - 같은 result를 받지만 다르게 처리 (콜백의 유연함)    

7. 익명 함수 (Anonymous Function) - 이름 없이 바로 전달 
    1) 함수에 이름 붙이지 않고 바로 전달
    2) 일회성 사용에 편리 
    3) 콜백 내부에서 어떤 연산이든 자유롭게 수행 가능 
    4) 예
        calculateAndProcess(10, 5, (result) => {
            console.log(result * result);           // 15 * 15 = 225
        });      

        